/* plugin.c generated by valac 0.30.1, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define SYNAPSE_TYPE_ACTIVATABLE (synapse_activatable_get_type ())
#define SYNAPSE_ACTIVATABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ACTIVATABLE, SynapseActivatable))
#define SYNAPSE_IS_ACTIVATABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ACTIVATABLE))
#define SYNAPSE_ACTIVATABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ACTIVATABLE, SynapseActivatableIface))

typedef struct _SynapseActivatable SynapseActivatable;
typedef struct _SynapseActivatableIface SynapseActivatableIface;

#define SYNAPSE_TYPE_CONFIGURABLE (synapse_configurable_get_type ())
#define SYNAPSE_CONFIGURABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_CONFIGURABLE, SynapseConfigurable))
#define SYNAPSE_IS_CONFIGURABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_CONFIGURABLE))
#define SYNAPSE_CONFIGURABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_CONFIGURABLE, SynapseConfigurableIface))

typedef struct _SynapseConfigurable SynapseConfigurable;
typedef struct _SynapseConfigurableIface SynapseConfigurableIface;

#define SYNAPSE_TYPE_ITEM_PROVIDER (synapse_item_provider_get_type ())
#define SYNAPSE_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ITEM_PROVIDER, SynapseItemProvider))
#define SYNAPSE_IS_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ITEM_PROVIDER))
#define SYNAPSE_ITEM_PROVIDER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ITEM_PROVIDER, SynapseItemProviderIface))

typedef struct _SynapseItemProvider SynapseItemProvider;
typedef struct _SynapseItemProviderIface SynapseItemProviderIface;

#define SYNAPSE_TYPE_QUERY (synapse_query_get_type ())

#define SYNAPSE_TYPE_QUERY_FLAGS (synapse_query_flags_get_type ())
typedef struct _SynapseQuery SynapseQuery;

#define SYNAPSE_TYPE_RESULT_SET (synapse_result_set_get_type ())
#define SYNAPSE_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSet))
#define SYNAPSE_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))
#define SYNAPSE_IS_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_IS_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_RESULT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))

typedef struct _SynapseResultSet SynapseResultSet;
typedef struct _SynapseResultSetClass SynapseResultSetClass;

#define SYNAPSE_TYPE_ACTION_PROVIDER (synapse_action_provider_get_type ())
#define SYNAPSE_ACTION_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_ACTION_PROVIDER, SynapseActionProvider))
#define SYNAPSE_IS_ACTION_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_ACTION_PROVIDER))
#define SYNAPSE_ACTION_PROVIDER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_ACTION_PROVIDER, SynapseActionProviderIface))

typedef struct _SynapseActionProvider SynapseActionProvider;
typedef struct _SynapseActionProviderIface SynapseActionProviderIface;

#define SYNAPSE_TYPE_MATCH (synapse_match_get_type ())
#define SYNAPSE_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_MATCH, SynapseMatch))
#define SYNAPSE_IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_MATCH))
#define SYNAPSE_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_MATCH, SynapseMatchIface))

typedef struct _SynapseMatch SynapseMatch;
typedef struct _SynapseMatchIface SynapseMatchIface;

#define SYNAPSE_TYPE_MATCH_TYPE (synapse_match_type_get_type ())

struct _SynapseActivatableIface {
	GTypeInterface parent_iface;
	void (*activate) (SynapseActivatable* self);
	void (*deactivate) (SynapseActivatable* self);
	gboolean (*get_enabled) (SynapseActivatable* self);
	void (*set_enabled) (SynapseActivatable* self, gboolean value);
};

struct _SynapseConfigurableIface {
	GTypeInterface parent_iface;
	GtkWidget* (*create_config_widget) (SynapseConfigurable* self);
};

typedef enum  {
	SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE = 1 << 0,
	SYNAPSE_QUERY_FLAGS_UNCATEGORIZED = 1 << 1,
	SYNAPSE_QUERY_FLAGS_APPLICATIONS = 1 << 2,
	SYNAPSE_QUERY_FLAGS_ACTIONS = 1 << 3,
	SYNAPSE_QUERY_FLAGS_AUDIO = 1 << 4,
	SYNAPSE_QUERY_FLAGS_VIDEO = 1 << 5,
	SYNAPSE_QUERY_FLAGS_DOCUMENTS = 1 << 6,
	SYNAPSE_QUERY_FLAGS_IMAGES = 1 << 7,
	SYNAPSE_QUERY_FLAGS_FILES = ((SYNAPSE_QUERY_FLAGS_AUDIO | SYNAPSE_QUERY_FLAGS_VIDEO) | SYNAPSE_QUERY_FLAGS_DOCUMENTS) | SYNAPSE_QUERY_FLAGS_IMAGES,
	SYNAPSE_QUERY_FLAGS_PLACES = 1 << 8,
	SYNAPSE_QUERY_FLAGS_INTERNET = 1 << 9,
	SYNAPSE_QUERY_FLAGS_TEXT = 1 << 10,
	SYNAPSE_QUERY_FLAGS_CONTACTS = 1 << 11,
	SYNAPSE_QUERY_FLAGS_ALL = 0xFFFFFFFFLL,
	SYNAPSE_QUERY_FLAGS_LOCAL_CONTENT = SYNAPSE_QUERY_FLAGS_ALL ^ SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE
} SynapseQueryFlags;

struct _SynapseQuery {
	gchar* query_string;
	gchar* query_string_folded;
	GCancellable* cancellable;
	SynapseQueryFlags query_type;
	guint max_results;
	guint query_id;
};

typedef enum  {
	SYNAPSE_SEARCH_ERROR_SEARCH_CANCELLED,
	SYNAPSE_SEARCH_ERROR_UNKNOWN_ERROR
} SynapseSearchError;
#define SYNAPSE_SEARCH_ERROR synapse_search_error_quark ()
struct _SynapseItemProviderIface {
	GTypeInterface parent_iface;
	void (*search) (SynapseItemProvider* self, SynapseQuery* query, GAsyncReadyCallback _callback_, gpointer _user_data_);
	SynapseResultSet* (*search_finish) (SynapseItemProvider* self, GAsyncResult* _res_, GError** error);
	gboolean (*handles_query) (SynapseItemProvider* self, SynapseQuery* query);
	gboolean (*handles_empty_query) (SynapseItemProvider* self);
};

typedef enum  {
	SYNAPSE_MATCH_TYPE_UNKNOWN = 0,
	SYNAPSE_MATCH_TYPE_TEXT,
	SYNAPSE_MATCH_TYPE_APPLICATION,
	SYNAPSE_MATCH_TYPE_GENERIC_URI,
	SYNAPSE_MATCH_TYPE_ACTION,
	SYNAPSE_MATCH_TYPE_SEARCH,
	SYNAPSE_MATCH_TYPE_CONTACT
} SynapseMatchType;

struct _SynapseMatchIface {
	GTypeInterface parent_iface;
	void (*execute) (SynapseMatch* self, SynapseMatch* match);
	void (*execute_with_target) (SynapseMatch* self, SynapseMatch* source, SynapseMatch* target);
	gboolean (*needs_target) (SynapseMatch* self);
	SynapseQueryFlags (*target_flags) (SynapseMatch* self);
	const gchar* (*get_title) (SynapseMatch* self);
	void (*set_title) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_description) (SynapseMatch* self);
	void (*set_description) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_icon_name) (SynapseMatch* self);
	void (*set_icon_name) (SynapseMatch* self, const gchar* value);
	gboolean (*get_has_thumbnail) (SynapseMatch* self);
	void (*set_has_thumbnail) (SynapseMatch* self, gboolean value);
	const gchar* (*get_thumbnail_path) (SynapseMatch* self);
	void (*set_thumbnail_path) (SynapseMatch* self, const gchar* value);
	SynapseMatchType (*get_match_type) (SynapseMatch* self);
	void (*set_match_type) (SynapseMatch* self, SynapseMatchType value);
};

struct _SynapseActionProviderIface {
	GTypeInterface parent_iface;
	SynapseResultSet* (*find_for_match) (SynapseActionProvider* self, SynapseQuery* query, SynapseMatch* match);
	gboolean (*handles_unknown) (SynapseActionProvider* self);
};



GType synapse_activatable_get_type (void) G_GNUC_CONST;
void synapse_activatable_activate (SynapseActivatable* self);
void synapse_activatable_deactivate (SynapseActivatable* self);
gboolean synapse_activatable_get_enabled (SynapseActivatable* self);
void synapse_activatable_set_enabled (SynapseActivatable* self, gboolean value);
GType synapse_configurable_get_type (void) G_GNUC_CONST;
GtkWidget* synapse_configurable_create_config_widget (SynapseConfigurable* self);
GType synapse_query_get_type (void) G_GNUC_CONST;
GType synapse_query_flags_get_type (void) G_GNUC_CONST;
SynapseQuery* synapse_query_dup (const SynapseQuery* self);
void synapse_query_free (SynapseQuery* self);
void synapse_query_copy (const SynapseQuery* self, SynapseQuery* dest);
void synapse_query_destroy (SynapseQuery* self);
GType synapse_result_set_get_type (void) G_GNUC_CONST;
GQuark synapse_search_error_quark (void);
GType synapse_item_provider_get_type (void) G_GNUC_CONST;
void synapse_item_provider_search (SynapseItemProvider* self, SynapseQuery* query, GAsyncReadyCallback _callback_, gpointer _user_data_);
SynapseResultSet* synapse_item_provider_search_finish (SynapseItemProvider* self, GAsyncResult* _res_, GError** error);
gboolean synapse_item_provider_handles_query (SynapseItemProvider* self, SynapseQuery* query);
static gboolean synapse_item_provider_real_handles_query (SynapseItemProvider* self, SynapseQuery* query);
gboolean synapse_item_provider_handles_empty_query (SynapseItemProvider* self);
static gboolean synapse_item_provider_real_handles_empty_query (SynapseItemProvider* self);
GType synapse_match_type_get_type (void) G_GNUC_CONST;
GType synapse_match_get_type (void) G_GNUC_CONST;
GType synapse_action_provider_get_type (void) G_GNUC_CONST;
SynapseResultSet* synapse_action_provider_find_for_match (SynapseActionProvider* self, SynapseQuery* query, SynapseMatch* match);
gboolean synapse_action_provider_handles_unknown (SynapseActionProvider* self);
static gboolean synapse_action_provider_real_handles_unknown (SynapseActionProvider* self);


void synapse_activatable_activate (SynapseActivatable* self) {
	g_return_if_fail (self != NULL);
	SYNAPSE_ACTIVATABLE_GET_INTERFACE (self)->activate (self);
}


void synapse_activatable_deactivate (SynapseActivatable* self) {
	g_return_if_fail (self != NULL);
	SYNAPSE_ACTIVATABLE_GET_INTERFACE (self)->deactivate (self);
}


gboolean synapse_activatable_get_enabled (SynapseActivatable* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SYNAPSE_ACTIVATABLE_GET_INTERFACE (self)->get_enabled (self);
}


void synapse_activatable_set_enabled (SynapseActivatable* self, gboolean value) {
	g_return_if_fail (self != NULL);
	SYNAPSE_ACTIVATABLE_GET_INTERFACE (self)->set_enabled (self, value);
}


static void synapse_activatable_base_init (SynapseActivatableIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_object_interface_install_property (iface, g_param_spec_boolean ("enabled", "enabled", "enabled", TRUE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	}
}


GType synapse_activatable_get_type (void) {
	static volatile gsize synapse_activatable_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_activatable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseActivatableIface), (GBaseInitFunc) synapse_activatable_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType synapse_activatable_type_id;
		synapse_activatable_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseActivatable", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (synapse_activatable_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&synapse_activatable_type_id__volatile, synapse_activatable_type_id);
	}
	return synapse_activatable_type_id__volatile;
}


GtkWidget* synapse_configurable_create_config_widget (SynapseConfigurable* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return SYNAPSE_CONFIGURABLE_GET_INTERFACE (self)->create_config_widget (self);
}


static void synapse_configurable_base_init (SynapseConfigurableIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType synapse_configurable_get_type (void) {
	static volatile gsize synapse_configurable_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_configurable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseConfigurableIface), (GBaseInitFunc) synapse_configurable_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType synapse_configurable_type_id;
		synapse_configurable_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseConfigurable", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (synapse_configurable_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&synapse_configurable_type_id__volatile, synapse_configurable_type_id);
	}
	return synapse_configurable_type_id__volatile;
}


void synapse_item_provider_search (SynapseItemProvider* self, SynapseQuery* query, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self)->search (self, query, _callback_, _user_data_);
}


SynapseResultSet* synapse_item_provider_search_finish (SynapseItemProvider* self, GAsyncResult* _res_, GError** error) {
	return SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self)->search_finish (self, _res_, error);
}


static gboolean synapse_item_provider_real_handles_query (SynapseItemProvider* self, SynapseQuery* query) {
	gboolean result = FALSE;
	g_return_val_if_fail (query != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean synapse_item_provider_handles_query (SynapseItemProvider* self, SynapseQuery* query) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self)->handles_query (self, query);
}


static gboolean synapse_item_provider_real_handles_empty_query (SynapseItemProvider* self) {
	gboolean result = FALSE;
	result = FALSE;
	return result;
}


gboolean synapse_item_provider_handles_empty_query (SynapseItemProvider* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SYNAPSE_ITEM_PROVIDER_GET_INTERFACE (self)->handles_empty_query (self);
}


static void synapse_item_provider_base_init (SynapseItemProviderIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		iface->handles_query = synapse_item_provider_real_handles_query;
		iface->handles_empty_query = synapse_item_provider_real_handles_empty_query;
	}
}


GType synapse_item_provider_get_type (void) {
	static volatile gsize synapse_item_provider_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_item_provider_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseItemProviderIface), (GBaseInitFunc) synapse_item_provider_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType synapse_item_provider_type_id;
		synapse_item_provider_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseItemProvider", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (synapse_item_provider_type_id, SYNAPSE_TYPE_ACTIVATABLE);
		g_once_init_leave (&synapse_item_provider_type_id__volatile, synapse_item_provider_type_id);
	}
	return synapse_item_provider_type_id__volatile;
}


SynapseResultSet* synapse_action_provider_find_for_match (SynapseActionProvider* self, SynapseQuery* query, SynapseMatch* match) {
	g_return_val_if_fail (self != NULL, NULL);
	return SYNAPSE_ACTION_PROVIDER_GET_INTERFACE (self)->find_for_match (self, query, match);
}


static gboolean synapse_action_provider_real_handles_unknown (SynapseActionProvider* self) {
	gboolean result = FALSE;
	result = FALSE;
	return result;
}


gboolean synapse_action_provider_handles_unknown (SynapseActionProvider* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SYNAPSE_ACTION_PROVIDER_GET_INTERFACE (self)->handles_unknown (self);
}


static void synapse_action_provider_base_init (SynapseActionProviderIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		iface->handles_unknown = synapse_action_provider_real_handles_unknown;
	}
}


GType synapse_action_provider_get_type (void) {
	static volatile gsize synapse_action_provider_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_action_provider_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseActionProviderIface), (GBaseInitFunc) synapse_action_provider_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType synapse_action_provider_type_id;
		synapse_action_provider_type_id = g_type_register_static (G_TYPE_INTERFACE, "SynapseActionProvider", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (synapse_action_provider_type_id, SYNAPSE_TYPE_ACTIVATABLE);
		g_once_init_leave (&synapse_action_provider_type_id__volatile, synapse_action_provider_type_id);
	}
	return synapse_action_provider_type_id__volatile;
}



